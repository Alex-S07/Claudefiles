<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>COA Module 1 ‚Äì Quick Study Guide</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Segoe UI', sans-serif; background: #0f1117; color: #e2e8f0; line-height: 1.7; }

  /* Header */
  .hero { background: linear-gradient(135deg, #1a1f35 0%, #0d2137 100%); padding: 40px 20px; text-align: center; border-bottom: 3px solid #00b4d8; }
  .hero h1 { font-size: 2rem; color: #00b4d8; font-weight: 800; letter-spacing: 1px; }
  .hero p { color: #90e0ef; margin-top: 8px; font-size: 1rem; }

  /* Nav TOC */
  .toc { background: #161b2e; padding: 20px; max-width: 900px; margin: 20px auto; border-radius: 12px; border: 1px solid #1e3a5f; }
  .toc h2 { color: #00b4d8; font-size: 1.1rem; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
  .toc-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px; }
  .toc a { color: #90caf9; text-decoration: none; background: #1e2a40; padding: 6px 12px; border-radius: 6px; font-size: 0.85rem; display: block; transition: background 0.2s; }
  .toc a:hover { background: #00b4d8; color: #000; }

  /* Main container */
  .container { max-width: 900px; margin: 0 auto; padding: 20px; }

  /* Section */
  .section { background: #161b2e; border-radius: 14px; border-left: 5px solid #00b4d8; padding: 24px; margin-bottom: 28px; }
  .section h2 { font-size: 1.35rem; color: #00e5ff; margin-bottom: 14px; display: flex; align-items: center; gap: 10px; }
  .section h2 .icon { font-size: 1.4rem; }
  .section h3 { color: #48cae4; font-size: 1rem; margin: 16px 0 8px; border-bottom: 1px dashed #1e3a5f; padding-bottom: 4px; }

  /* Memory trick */
  .mnemonic { background: #0d2e1f; border: 1px solid #00b050; border-radius: 8px; padding: 12px 16px; margin: 12px 0; }
  .mnemonic .label { font-size: 0.72rem; text-transform: uppercase; letter-spacing: 1px; color: #52c41a; font-weight: 700; margin-bottom: 4px; }
  .mnemonic p { color: #b7eb8f; font-size: 0.9rem; }

  /* Key point box */
  .keybox { background: #1a2a1a; border-left: 4px solid #52c41a; padding: 10px 14px; border-radius: 6px; margin: 10px 0; font-size: 0.9rem; }

  /* Table */
  table { width: 100%; border-collapse: collapse; font-size: 0.88rem; margin: 12px 0; }
  th { background: #00b4d8; color: #000; padding: 8px 10px; text-align: left; font-weight: 700; }
  td { padding: 7px 10px; border-bottom: 1px solid #1e3a5f; }
  tr:nth-child(even) td { background: #1a2035; }

  /* Code inline */
  code { background: #1e3a5f; color: #90e0ef; padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 0.88em; }

  /* Tag */
  .tag { display: inline-block; background: #0077b6; color: #fff; font-size: 0.72rem; padding: 2px 8px; border-radius: 10px; margin: 2px; font-weight: 600; }
  .tag.red { background: #c1121f; }
  .tag.green { background: #2d6a4f; }
  .tag.orange { background: #e36414; }
  .tag.purple { background: #6a0dad; }

  /* Flash card */
  .flashcard-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 14px; margin: 12px 0; }
  .card { background: #1e2a40; border-radius: 10px; padding: 16px; border-top: 3px solid #00b4d8; }
  .card .front { font-weight: 700; color: #90e0ef; margin-bottom: 8px; font-size: 0.95rem; }
  .card .back { color: #cbd5e1; font-size: 0.87rem; }

  /* Comparison */
  .compare { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin: 12px 0; }
  .compare-box { background: #1e2a40; border-radius: 10px; padding: 14px; }
  .compare-box h4 { text-align: center; margin-bottom: 10px; font-size: 0.95rem; padding: 4px; border-radius: 4px; }
  .compare-box.arch h4 { background: #0077b6; color: #fff; }
  .compare-box.org h4 { background: #5e6ad2; color: #fff; }
  .compare-box ul { list-style: none; padding: 0; }
  .compare-box ul li { font-size: 0.85rem; padding: 3px 0; color: #cbd5e1; }
  .compare-box ul li::before { content: "‚Üí "; color: #00b4d8; }

  /* Step sequence */
  .steps { counter-reset: step; }
  .step { display: flex; align-items: flex-start; gap: 14px; margin: 8px 0; }
  .step-num { background: #00b4d8; color: #000; font-weight: 800; min-width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.85rem; flex-shrink: 0; }
  .step-text { color: #cbd5e1; font-size: 0.9rem; padding-top: 4px; }

  /* Addressing mode cards */
  .mode-card { background: #1e2a40; border-radius: 10px; padding: 14px; margin: 10px 0; border-left: 4px solid #5e6ad2; }
  .mode-card h4 { color: #c4b5fd; margin-bottom: 6px; font-size: 0.95rem; }
  .mode-card .formula { font-family: monospace; color: #fbbf24; font-size: 0.9rem; margin: 4px 0; }
  .mode-card p { color: #cbd5e1; font-size: 0.87rem; }
  .mode-card .ex { color: #86efac; font-family: monospace; font-size: 0.85rem; margin-top: 6px; }

  /* Flag table */
  .flag { display: flex; align-items: center; gap: 12px; padding: 8px 12px; border-radius: 8px; margin: 6px 0; }
  .flag-letter { font-size: 1.4rem; font-weight: 900; color: #fbbf24; min-width: 30px; }
  .flag-name { color: #90e0ef; font-weight: 700; min-width: 90px; font-size: 0.9rem; }
  .flag-desc { color: #cbd5e1; font-size: 0.87rem; }
  .flag.n { background: #1f1015; }
  .flag.z { background: #101f14; }
  .flag.v { background: #1f1a10; }
  .flag.c { background: #101520; }

  /* Quick recall */
  .recall { background: #1f1a00; border: 1px solid #fbbf24; border-radius: 8px; padding: 14px; margin: 14px 0; }
  .recall .rl { font-size: 0.72rem; color: #fbbf24; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }

  /* Horizontal rule */
  hr { border: none; border-top: 1px solid #1e3a5f; margin: 18px 0; }

  @media (max-width: 600px) {
    .compare { grid-template-columns: 1fr; }
    .flashcard-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<div class="hero">
  <h1>üñ•Ô∏è Computer Organization &amp; Architecture</h1>
  <p>Module 1 ‚Äî Complete Exam Study Guide | Easy to memorise, nothing skipped</p>
</div>

<!-- TOC -->
<div class="toc">
  <h2>üìã Topics at a Glance</h2>
  <div class="toc-grid">
    <a href="#s1">1. CA vs CO</a>
    <a href="#s2">2. Basic Structure</a>
    <a href="#s3">3. Functional Units</a>
    <a href="#s4">4. Basic Operational Concepts</a>
    <a href="#s5">5. Registers (IR, PC, MAR, MDR)</a>
    <a href="#s6">6. Interrupts</a>
    <a href="#s7">7. Bus Structures</a>
    <a href="#s8">8. Memory Locations &amp; Addresses</a>
    <a href="#s9">9. Byte Addressability / Endian</a>
    <a href="#s10">10. Memory Operations</a>
    <a href="#s11">11. Instructions &amp; Sequencing</a>
    <a href="#s12">12. Instruction Types</a>
    <a href="#s13">13. Branching &amp; Loops</a>
    <a href="#s14">14. Condition Codes</a>
    <a href="#s15">15. Addressing Modes</a>
    <a href="#s16">16. Basic Processing Unit</a>
    <a href="#s17">17. Instruction Cycle</a>
    <a href="#s18">18. Single vs Multiple Bus</a>
  </div>
</div>

<div class="container">

<!-- ===== SECTION 1 ===== -->
<div class="section" id="s1">
  <h2><span class="icon">üèõÔ∏è</span> 1. Computer Architecture vs Computer Organization</h2>

  <div class="compare">
    <div class="compare-box arch">
      <h4>Computer Architecture (CA)</h4>
      <ul>
        <li>Describes <strong>WHAT</strong> the computer does</li>
        <li>Functional behavior of the system</li>
        <li>Coordinates hardware &amp; software</li>
        <li>Indicates hardware</li>
        <li>Decided <strong>FIRST</strong> when designing a computer</li>
      </ul>
    </div>
    <div class="compare-box org">
      <h4>Computer Organization (CO)</h4>
      <ul>
        <li>Describes <strong>HOW</strong> it does it</li>
        <li>Structural relationships</li>
        <li>Handles network segments</li>
        <li>Indicates performance</li>
        <li>Decided <strong>AFTER</strong> architecture</li>
      </ul>
    </div>
  </div>

  <div class="mnemonic">
    <div class="label">üß† Memory Trick</div>
    <p><strong>CA = Blueprint (what to build) | CO = Construction (how to build)</strong><br>
    Think of CA as the architect's drawing, CO as the workers building it.</p>
  </div>

  <div class="keybox">
    Analogy: CO examines lumber, bricks and nails (materials). CA looks at the design of the house (integration of materials).
  </div>
</div>

<!-- ===== SECTION 2 ===== -->
<div class="section" id="s2">
  <h2><span class="icon">üèóÔ∏è</span> 2. Basic Structure of Computers</h2>
  <p>A computer is a fast electronic calculating machine that:</p>
  <div class="steps">
    <div class="step"><div class="step-num">1</div><div class="step-text">Accepts <strong>digitized input information</strong></div></div>
    <div class="step"><div class="step-num">2</div><div class="step-text">Processes the information according to a list of <strong>internally stored instructions</strong></div></div>
    <div class="step"><div class="step-num">3</div><div class="step-text">Produces the results as <strong>output information</strong></div></div>
  </div>
  <div class="keybox" style="margin-top:12px">The instructions = <strong>Computer Program</strong> | Internal storage = <strong>Memory</strong></div>
</div>

<!-- ===== SECTION 3 ===== -->
<div class="section" id="s3">
  <h2><span class="icon">‚öôÔ∏è</span> 3. Functional Units of a Computer</h2>

  <div class="mnemonic">
    <div class="label">üß† Memory Trick ‚Äì 5 Units</div>
    <p><strong>"I MAC O"</strong> ‚Üí <strong>I</strong>nput, <strong>M</strong>emory, <strong>A</strong>LU, <strong>C</strong>ontrol, <strong>O</strong>utput</p>
  </div>

  <div class="flashcard-grid">
    <div class="card">
      <div class="front">üîå Input Unit</div>
      <div class="back">Accepts coded information from outside. Translates keypresses to binary and sends to memory/processor. E.g. Keyboard, Mouse, Joystick, Trackball.</div>
    </div>
    <div class="card">
      <div class="front">üíæ Memory Unit</div>
      <div class="back">Stores programs &amp; data. Two classes: <strong>Primary (RAM, Cache)</strong> ‚Äî fast, semiconductor; <strong>Secondary (HDD, CD-ROM)</strong> ‚Äî larger, cheaper, slower.</div>
    </div>
    <div class="card">
      <div class="front">üî¢ ALU (Arithmetic &amp; Logic Unit)</div>
      <div class="back">Executes arithmetic (+, ‚Äì, √ó, √∑) and logical operations. Operands are fetched from memory, processed, then result is stored back.</div>
    </div>
    <div class="card">
      <div class="front">üñ•Ô∏è Output Unit</div>
      <div class="back">Sends processed results to the outside world. Converts binary output to human-readable form. E.g. Monitor, Printer, Speaker.</div>
    </div>
    <div class="card">
      <div class="front">üéõÔ∏è Control Unit</div>
      <div class="back">Controls ALL computer operations. Generates timing signals for I/O transfers. Usually distributed throughout the machine, not standalone. Decides <em>when</em> operations happen.</div>
    </div>
  </div>

  <h3>Memory Hierarchy (Fast ‚Üí Slow)</h3>
  <table>
    <tr><th>Level</th><th>Type</th><th>Speed</th><th>Size</th><th>Cost</th></tr>
    <tr><td>1</td><td>Cache (L1/L2/L3)</td><td>Fastest</td><td>Smallest</td><td>Highest</td></tr>
    <tr><td>2</td><td>Main Memory (RAM)</td><td>Fast</td><td>Medium</td><td>Medium</td></tr>
    <tr><td>3</td><td>Secondary (HDD/SSD)</td><td>Slow</td><td>Largest</td><td>Lowest</td></tr>
  </table>

  <div class="keybox"><strong>Memory Access Time</strong> = Time required to access 1 word from memory. Cache has lower access time than main memory because it uses high-speed SRAM and is physically closer to the CPU.</div>

  <h3>Primary Memory Classification</h3>
  <div class="keybox">
    <strong>RAM (Random Access Memory)</strong> ‚Äî volatile, fixed access time regardless of location.<br>
    <strong>ROM (Read Only Memory)</strong> ‚Äî non-volatile, read-only.<br>
    <strong>Cache</strong> ‚Äî small, ultra-fast SRAM between CPU and main memory.
  </div>
</div>

<!-- ===== SECTION 4 ===== -->
<div class="section" id="s4">
  <h2><span class="icon">üí°</span> 4. Basic Operational Concepts</h2>
  <p>Data/Operands are stored in memory. Instructions are fetched one at a time from memory to the processor.</p>

  <h3>Example Instructions</h3>
  <div class="keybox">
    <code>Add LOC_A, R0</code><br>
    ‚Üí Add operand at memory location LOC_A with contents of register R0; result stored in R0
  </div>
  <div class="keybox">
    <code>Move LOC_A, R1</code> ‚Üí transfer contents of LOC_A into register R1<br>
    <code>Add R1, R0</code> ‚Üí add R1 and R0, place result in R0
  </div>

  <h3>How Processor-Memory Transfer Works</h3>
  <div class="steps">
    <div class="step"><div class="step-num">1</div><div class="step-text">Processor sends the <strong>address</strong> of the memory location</div></div>
    <div class="step"><div class="step-num">2</div><div class="step-text">Appropriate <strong>control signals</strong> are issued</div></div>
    <div class="step"><div class="step-num">3</div><div class="step-text">Data is <strong>transferred to or from</strong> the memory</div></div>
  </div>
</div>

<!-- ===== SECTION 5 ===== -->
<div class="section" id="s5">
  <h2><span class="icon">üìã</span> 5. Key Processor Registers</h2>

  <div class="flashcard-grid">
    <div class="card">
      <div class="front">IR ‚Äî Instruction Register</div>
      <div class="back">Holds the <strong>currently executing instruction</strong>. Its output goes to control circuits that generate timing signals for execution.</div>
    </div>
    <div class="card">
      <div class="front">PC ‚Äî Program Counter</div>
      <div class="back">Keeps track of program execution. Holds the <strong>address of the NEXT instruction</strong> to be fetched. Incremented by 4 after each fetch (byte-addressable, 32-bit).</div>
    </div>
    <div class="card">
      <div class="front">MAR ‚Äî Memory Address Register</div>
      <div class="back">Holds the <strong>address of the memory location</strong> to be accessed (read/write).</div>
    </div>
    <div class="card">
      <div class="front">MDR ‚Äî Memory Data Register</div>
      <div class="back">Holds the <strong>data to be written into</strong> OR <strong>read out of</strong> the addressed memory location.</div>
    </div>
    <div class="card">
      <div class="front">General Purpose Registers (R0‚ÄìRn-1)</div>
      <div class="back">Besides IR and PC, there are n general-purpose registers used to hold operands and results during computation. Much faster than memory access.</div>
    </div>
  </div>

  <div class="mnemonic">
    <div class="label">üß† Memory Trick</div>
    <p><strong>IR</strong> = "I'm Running this instruction" | <strong>PC</strong> = "Points to the Coming instruction"<br>
    <strong>MAR</strong> = "Memory Address Reader" | <strong>MDR</strong> = "Memory Data Reader"</p>
  </div>
</div>

<!-- ===== SECTION 6 ===== -->
<div class="section" id="s6">
  <h2><span class="icon">üîî</span> 6. Interrupts</h2>
  <div class="keybox">
    An <strong>interrupt</strong> is a request from an I/O device for service by the processor.
  </div>
  <p style="margin-top:10px; font-size:0.9rem; color:#cbd5e1">When an interrupt occurs:</p>
  <div class="steps">
    <div class="step"><div class="step-num">1</div><div class="step-text">The current processor <strong>state is saved</strong> to memory</div></div>
    <div class="step"><div class="step-num">2</div><div class="step-text">Contents of PC, general purpose registers, and control info are stored</div></div>
    <div class="step"><div class="step-num">3</div><div class="step-text">The processor executes an <strong>interrupt-service routine</strong></div></div>
    <div class="step"><div class="step-num">4</div><div class="step-text">Processor restores saved state and resumes normal execution</div></div>
  </div>
</div>

<!-- ===== SECTION 7 ===== -->
<div class="section" id="s7">
  <h2><span class="icon">üöå</span> 7. Bus Structures</h2>

  <div class="keybox"><strong>Bus</strong> = A group of lines (wires) that connects multiple devices. Has lines for <strong>Data, Address, and Control</strong> purposes.</div>

  <div class="compare">
    <div class="compare-box arch">
      <h4>Single Bus Structure</h4>
      <ul>
        <li>All units connected to ONE bus</li>
        <li>Only ONE transfer at a time</li>
        <li>Only TWO units can be active at once</li>
        <li>‚úÖ Low cost</li>
        <li>‚úÖ Very flexible</li>
        <li>‚ùå Slow ‚Äì bottleneck</li>
      </ul>
    </div>
    <div class="compare-box org">
      <h4>Multiple Bus Structure</h4>
      <ul>
        <li>MORE than one bus</li>
        <li>Allows concurrent transfers</li>
        <li>Buffer (cache) registers solve speed mismatch</li>
        <li>‚úÖ Higher performance</li>
        <li>‚úÖ More concurrency</li>
        <li>‚ùå Higher cost</li>
      </ul>
    </div>
  </div>

  <div class="mnemonic">
    <div class="label">üß† Memory Trick</div>
    <p><strong>Single bus = Highway with 1 lane</strong> (cheap but traffic jams) | <strong>Multiple bus = Multi-lane expressway</strong> (expensive but fast)</p>
  </div>
</div>

<!-- ===== SECTION 8 ===== -->
<div class="section" id="s8">
  <h2><span class="icon">üìç</span> 8. Memory Locations &amp; Addresses</h2>

  <div class="flashcard-grid">
    <div class="card">
      <div class="front">Storage Cell</div>
      <div class="back">Smallest unit. Each cell stores <strong>1 bit</strong> (0 or 1).</div>
    </div>
    <div class="card">
      <div class="front">Word</div>
      <div class="back">Group of cells treated as a unit. <strong>Word Length = 16 to 64 bits</strong>.</div>
    </div>
    <div class="card">
      <div class="front">Address</div>
      <div class="back">Distinct number assigned to each memory location. Addresses identify successive locations.</div>
    </div>
    <div class="card">
      <div class="front">Word Length</div>
      <div class="back">Number of bits in each word. Ranges from <strong>16 to 64 bits</strong>.</div>
    </div>
  </div>

  <div class="keybox">Memory = millions of storage cells ‚Üí grouped into words ‚Üí each word has a unique address ‚Üí address = how CPU finds data</div>
</div>

<!-- ===== SECTION 9 ===== -->
<div class="section" id="s9">
  <h2><span class="icon">üî¢</span> 9. Byte Addressability, Big-Endian &amp; Little-Endian</h2>

  <h3>Byte Addressability</h3>
  <div class="keybox">Assigning addresses to individual <em>bits</em> is impractical. Instead, successive addresses refer to successive <strong>bytes</strong>. This is called <strong>byte-addressable memory</strong> and is used in all modern computers.</div>

  <h3>Big-Endian vs Little-Endian</h3>
  <table>
    <tr><th>Type</th><th>Definition</th><th>Example (word 12345678h)</th></tr>
    <tr><td><strong>Big-Endian</strong></td><td>Lower byte address = <em>most</em> significant byte (leftmost)</td><td>Address 0 ‚Üí 12, Address 1 ‚Üí 34 ‚Ä¶</td></tr>
    <tr><td><strong>Little-Endian</strong></td><td>Lower byte address = <em>least</em> significant byte (rightmost)</td><td>Address 0 ‚Üí 78, Address 1 ‚Üí 56 ‚Ä¶</td></tr>
  </table>

  <div class="mnemonic">
    <div class="label">üß† Memory Trick</div>
    <p><strong>Big-Endian</strong> = "Big (most significant) end first" ‚Äî like writing a big number left to right.<br>
    <strong>Little-Endian</strong> = "Little (least significant) end first" ‚Äî reversed.</p>
  </div>

  <h3>Word Alignment</h3>
  <div class="keybox">
    <strong>Aligned address</strong> ‚Äî follows byte addressing rules (address is a multiple of word size).<br>
    <strong>Unaligned address</strong> ‚Äî does not follow byte addressing.
  </div>
</div>

<!-- ===== SECTION 10 ===== -->
<div class="section" id="s10">
  <h2><span class="icon">üíæ</span> 10. Memory Operations</h2>

  <div class="keybox">Two basic memory operations: <strong>Load (Read/Fetch)</strong> and <strong>Store (Write)</strong></div>

  <div class="compare">
    <div class="compare-box arch">
      <h4>LOAD (Read/Fetch)</h4>
      <ul>
        <li>Processor sends address to memory</li>
        <li>Requests contents be read</li>
        <li>Memory reads data at that address</li>
        <li>Data sent to the processor</li>
      </ul>
    </div>
    <div class="compare-box org">
      <h4>STORE (Write)</h4>
      <ul>
        <li>Processor sends address to memory</li>
        <li>Also sends data to be written</li>
        <li>Data written to that location</li>
        <li>Previous contents are destroyed</li>
      </ul>
    </div>
  </div>
</div>

<!-- ===== SECTION 11 ===== -->
<div class="section" id="s11">
  <h2><span class="icon">üìù</span> 11. Instructions &amp; Instruction Sequencing</h2>

  <h3>4 Types of Instructions a Computer Must Have</h3>
  <div class="mnemonic">
    <div class="label">üß† Memory Trick ‚Äî "DAPI"</div>
    <p><strong>D</strong>ata transfers (memory ‚Üî processor) | <strong>A</strong>rithmetic &amp; Logic operations | <strong>P</strong>rogram sequencing &amp; control | <strong>I</strong>/O transfers</p>
  </div>

  <h3>Register Transfer Notation (RTN)</h3>
  <div class="keybox">
    Describes info transfer from one location to another.<br>
    <code>R1 ‚Üê [LOC]</code> ‚Üí contents of memory location LOC transferred into R1<br>
    <code>R3 ‚Üê [R1] + [R2]</code> ‚Üí R1 and R2 added, result placed in R3<br>
    <strong>[ ] = contents of location</strong> | LHS = destination | RHS = value
  </div>

  <h3>Assembly Language Notation</h3>
  <div class="keybox">
    <code>Move LOC, R1</code> ‚Üí transfer contents of LOC to R1<br>
    <code>Add R1, R2, R3</code> ‚Üí R1 + R2 ‚Üí R3
  </div>

  <h3>Straight-Line Sequencing</h3>
  <div class="keybox">
    PC holds address of first instruction. Instructions are fetched and executed in <strong>increasing address order</strong>. After each fetch, PC is incremented by <strong>4</strong> (for 32-bit word, byte-addressable). This is called <strong>straight-line sequencing</strong>.
  </div>
</div>

<!-- ===== SECTION 12 ===== -->
<div class="section" id="s12">
  <h2><span class="icon">üî£</span> 12. Basic Instruction Types</h2>

  <p style="margin-bottom:12px; color:#cbd5e1; font-size:0.9rem">All based on the statement <code>C = A + B</code>:</p>

  <table>
    <tr><th>Type</th><th>Operands</th><th>Format</th><th>Example</th></tr>
    <tr>
      <td><strong>3-Address</strong></td>
      <td>Source1, Source2, Destination</td>
      <td><code>Op Src1, Src2, Dest</code></td>
      <td><code>Add A, B, C</code> ‚Üí C ‚Üê A+B</td>
    </tr>
    <tr>
      <td><strong>2-Address</strong></td>
      <td>Source, Destination (result overwrites)</td>
      <td><code>Op Src, Dest</code></td>
      <td><code>Add A, B</code> ‚Üí B ‚Üê A+B; <code>Move B, C</code></td>
    </tr>
    <tr>
      <td><strong>1-Address</strong></td>
      <td>Single operand (uses Accumulator)</td>
      <td><code>Op Operand</code></td>
      <td><code>Load A; Add B; Store C</code></td>
    </tr>
    <tr>
      <td><strong>0-Address</strong></td>
      <td>No operands (implicit ‚Äì stack)</td>
      <td><code>Op</code></td>
      <td>Pushdown stack operations</td>
    </tr>
  </table>

  <div class="keybox">
    1-address instruction uses an <strong>Accumulator</strong> as the implicit second operand. The Accumulator holds intermediate results.
  </div>

  <h3>Opcode &amp; Operands</h3>
  <div class="keybox">
    <strong>Opcode</strong> = Operation Code; tells CPU what to do (e.g., MOV, ADD, JMP). In binary for machine language; mnemonic for assembly.<br>
    <strong>Operands</strong> = the data/addresses on which the operation is performed.<br>
    Example: <code>MOV AX, 34h</code> ‚Üí Opcode = MOV, Operands = AX and 34h
  </div>
</div>

<!-- ===== SECTION 13 ===== -->
<div class="section" id="s13">
  <h2><span class="icon">üîÄ</span> 13. Branching &amp; Loops</h2>

  <h3>Branching</h3>
  <div class="keybox">
    Branching allows program execution to jump to a different location rather than continuing sequentially. Used to implement <strong>loops</strong> and <strong>conditional logic</strong>.
  </div>

  <h3>Straight-line vs Loop (Adding n numbers)</h3>
  <div class="compare">
    <div class="compare-box arch">
      <h4>Straight-Line (No Loop)</h4>
      <ul>
        <li>Separate Add instruction for each number</li>
        <li>Very long program</li>
        <li>Not scalable</li>
        <li>NUM1, NUM2, ..., NUMn each added separately</li>
        <li>Result stored in SUM</li>
      </ul>
    </div>
    <div class="compare-box org">
      <h4>Loop</h4>
      <ul>
        <li>n stored in memory location N</li>
        <li>R1 used as counter (loaded from N)</li>
        <li><code>Decrement R1</code> reduces counter</li>
        <li><code>Branch &gt; 0</code> loops if R1 &gt; 0</li>
        <li>Compact and scalable</li>
      </ul>
    </div>
  </div>

  <div class="mnemonic">
    <div class="label">üß† Key Concept</div>
    <p><strong>Conditional Branch</strong> = branch only if a condition is satisfied (e.g., Branch &gt; 0 = branch if result is positive).</p>
  </div>
</div>

<!-- ===== SECTION 14 ===== -->
<div class="section" id="s14">
  <h2><span class="icon">üö©</span> 14. Condition Codes (Flags)</h2>

  <div class="keybox">The processor tracks results of operations using <strong>condition code flags</strong> stored in the <strong>Condition Code Register (Status Register)</strong>.</div>

  <div class="flag n"><div class="flag-letter">N</div><div class="flag-name">Negative</div><div class="flag-desc">Set to 1 if result is negative; 0 otherwise</div></div>
  <div class="flag z"><div class="flag-letter">Z</div><div class="flag-name">Zero</div><div class="flag-desc">Set to 1 if result is zero; 0 otherwise</div></div>
  <div class="flag v"><div class="flag-letter">V</div><div class="flag-name">oVerflow</div><div class="flag-desc">Set to 1 if arithmetic overflow occurs; 0 otherwise</div></div>
  <div class="flag c"><div class="flag-letter">C</div><div class="flag-name">Carry</div><div class="flag-desc">Set to 1 if a carry-out results from the operation; 0 otherwise</div></div>

  <div class="mnemonic">
    <div class="label">üß† Memory Trick</div>
    <p><strong>"N-Z-V-C"</strong> ‚Üí "Never Zero Value Carry" or just remember <strong>NZVC</strong> flags</p>
  </div>
</div>

<!-- ===== SECTION 15 ===== -->
<div class="section" id="s15">
  <h2><span class="icon">üó∫Ô∏è</span> 15. Addressing Modes</h2>

  <div class="keybox"><strong>Addressing Mode</strong> = The way in which the location (effective address) of an operand is specified in an instruction.<br>
  <strong>Effective Address (EA)</strong> = The actual memory location of the operand.</div>

  <div class="mnemonic">
    <div class="label">üß† Memory Trick ‚Äî All modes</div>
    <p><strong>"I DRIRI-D-Stack"</strong> ‚Üí Immediate, Direct, Register, Indirect, Register Indirect, Indexed/Displacement, Stack | Also: Relative, Autoincrement, Autodecrement</p>
  </div>

  <div class="mode-card">
    <h4>1. Immediate Addressing Mode</h4>
    <div class="formula">Operand = value in instruction itself</div>
    <p>The operand (actual value) is part of the instruction ‚Äî no memory reference needed.</p>
    <div class="ex">Move #200, R0 ‚Üí R0 ‚Üê 200 | ADD AX, 5h ‚Üí adds literal 5</div>
    <p style="margin-top:6px; color:#f87171">‚úÖ Fast | ‚ùå Limited range | Used for constants</p>
  </div>

  <div class="mode-card">
    <h4>2. Direct (Absolute) Addressing Mode</h4>
    <div class="formula">EA = Address field (A)</div>
    <p>Address field in instruction contains the direct memory address of the operand.</p>
    <div class="ex">Move A, R2 ‚Üí R2 ‚Üê Memory[A]</div>
    <p style="margin-top:6px; color:#f87171">‚úÖ Simple | ‚ùå Limited address space</p>
  </div>

  <div class="mode-card">
    <h4>3. Register Addressing Mode</h4>
    <div class="formula">EA = Register (operand IS in a register)</div>
    <p>The operand is in a register named in the instruction. No memory access required.</p>
    <div class="ex">MOV R0, R1 | ADD R1, R2</div>
    <p style="margin-top:6px; color:#f87171">‚úÖ Very fast, no memory access | ‚ùå Very limited space</p>
  </div>

  <div class="mode-card">
    <h4>4. Indirect Addressing Mode</h4>
    <div class="formula">EA = Memory[A] ‚Äî A contains the address of the operand (pointer)</div>
    <p>The instruction points to a register/memory location that holds the address of the operand (two-level lookup).</p>
    <div class="ex">MOV (R), B ‚Üí R holds address A; operand is at Memory[A]</div>
    <p style="margin-top:6px; color:#f87171">‚úÖ Large address space (2‚Åø) | ‚ùå Slower (multiple memory accesses) | Can be multilevel</p>
  </div>

  <div class="mode-card">
    <h4>5. Register Indirect Addressing Mode</h4>
    <div class="formula">EA = (R) ‚Äî content of register R is the address</div>
    <p>Operand is in memory at the address held in a register. One fewer memory access than indirect.</p>
    <div class="ex">ADD (R1), R0 ‚Üí R1 holds address; add Memory[R1] to R0</div>
    <p style="margin-top:6px; color:#f87171">‚úÖ Large address space | ‚úÖ Faster than indirect</p>
  </div>

  <div class="mode-card">
    <h4>6. Indexed (Displacement) Addressing Mode</h4>
    <div class="formula">EA = X + (Ri) ‚Äî constant X added to register Ri</div>
    <p>Effective address = base address (in register) + offset (constant X in instruction). Also called displacement mode.</p>
    <div class="ex">X(Ri) ‚Üí EA = X + [Ri]</div>
    <p style="margin-top:6px; color:#f87171">‚úÖ Flexible for array access | Used for arrays and structures</p>
  </div>

  <div class="mode-card">
    <h4>7. Relative Addressing Mode</h4>
    <div class="formula">EA = PC + offset</div>
    <p>Uses Program Counter (PC) instead of a general register. Offset (signed) is added to PC. Commonly used in branch instructions.</p>
    <div class="ex">BRANCH &gt;0  LOOP ‚Üí jumps to LOOP if condition satisfied</div>
    <p style="margin-top:6px; color:#f87171">‚úÖ Position-independent code | Offset can be + or ‚Äì</p>
  </div>

  <div class="mode-card">
    <h4>8. Autoincrement Mode</h4>
    <div class="formula">EA = (Ri), then Ri ‚Üê Ri + 1/2/4</div>
    <p>Effective address = content of register. After access, register is automatically incremented (by 1 for byte, 2 for word, 4 for longword).</p>
    <div class="ex">(Ri)+ ‚Äî used for sequential memory access</div>
  </div>

  <div class="mode-card">
    <h4>9. Autodecrement Mode</h4>
    <div class="formula">Ri ‚Üê Ri ‚Äì 1/2/4, then EA = (Ri)</div>
    <p>Register is first decremented, then used as the effective address. Opposite of autoincrement.</p>
    <div class="ex">‚Äì(Ri) ‚Äî used for stack operations (LIFO)</div>
  </div>

  <div class="mode-card" style="border-left-color: #f59e0b;">
    <h4>10. Stack Addressing Mode</h4>
    <div class="formula">Operand is implicitly on top of the stack</div>
    <p>No address field needed ‚Äî operand is always the top of stack (TOS). Uses autoincrement/autodecrement.</p>
    <div class="ex">ADD ‚Üí pops top two items, adds them, pushes result</div>
  </div>

  <h3>Quick Comparison Table</h3>
  <table>
    <tr><th>Mode</th><th>EA Formula</th><th>Speed</th><th>Use Case</th></tr>
    <tr><td>Immediate</td><td>Operand in instruction</td><td>Fastest</td><td>Constants</td></tr>
    <tr><td>Register</td><td>EA = Ri</td><td>Very Fast</td><td>Variables in CPU</td></tr>
    <tr><td>Direct</td><td>EA = A</td><td>Fast</td><td>Global variables</td></tr>
    <tr><td>Register Indirect</td><td>EA = (Ri)</td><td>Fast</td><td>Pointers</td></tr>
    <tr><td>Indirect</td><td>EA = M[A]</td><td>Slow</td><td>Pointer to pointer</td></tr>
    <tr><td>Indexed</td><td>EA = X + (Ri)</td><td>Medium</td><td>Arrays</td></tr>
    <tr><td>Relative</td><td>EA = PC + offset</td><td>Medium</td><td>Branches</td></tr>
    <tr><td>Autoincrement</td><td>EA=(Ri), Ri++</td><td>Medium</td><td>Sequential access</td></tr>
    <tr><td>Autodecrement</td><td>Ri--, EA=(Ri)</td><td>Medium</td><td>Stack (push)</td></tr>
  </table>
</div>

<!-- ===== SECTION 16 ===== -->
<div class="section" id="s16">
  <h2><span class="icon">üß©</span> 16. Basic Processing Unit ‚Äî Fundamental Concepts</h2>

  <div class="keybox">
    Processor fetches one instruction at a time and performs the operation specified. Instructions are fetched from <strong>successive memory locations</strong>. PC tracks the address of the next instruction. IR holds the current instruction.
  </div>

  <h3>Executing an Instruction (3 micro-steps)</h3>
  <div class="steps">
    <div class="step"><div class="step-num">1</div><div class="step-text"><strong>Fetch:</strong> IR ‚Üê [[PC]] ‚Äî load instruction pointed to by PC into IR</div></div>
    <div class="step"><div class="step-num">2</div><div class="step-text"><strong>Increment PC:</strong> PC ‚Üê [PC] + 4 ‚Äî point to next instruction</div></div>
    <div class="step"><div class="step-num">3</div><div class="step-text"><strong>Execute:</strong> Carry out actions specified by IR</div></div>
  </div>

  <h3>Performing ALU Operation (example: R1 + R2 ‚Üí R3)</h3>
  <div class="keybox">
    ALU is a combinational circuit with no internal storage. Result is temporarily stored in register Z.<br><br>
    Step 1: <code>R1out, Yin</code> ‚Üí R1 value goes to Y register<br>
    Step 2: <code>R2out, SelectY, Add, Zin</code> ‚Üí R2 + Y, result in Z<br>
    Step 3: <code>Zout, R3in</code> ‚Üí Z value goes to R3
  </div>

  <h3>Fetching a Word from Memory (Move (R1), R2)</h3>
  <div class="steps">
    <div class="step"><div class="step-num">1</div><div class="step-text">MAR ‚Üê [R1]</div></div>
    <div class="step"><div class="step-num">2</div><div class="step-text">Start a Read operation on memory bus</div></div>
    <div class="step"><div class="step-num">3</div><div class="step-text">WMFC ‚Äî Wait for Memory Function Completed signal</div></div>
    <div class="step"><div class="step-num">4</div><div class="step-text">Load MDR from memory bus</div></div>
    <div class="step"><div class="step-num">5</div><div class="step-text">R2 ‚Üê [MDR]</div></div>
  </div>

  <div class="keybox"><strong>MFC (Memory Function Completed)</strong> = signal sent by memory to processor indicating the read/write operation is done. Processor waits (WMFC) because memory access time varies.</div>
</div>

<!-- ===== SECTION 17 ===== -->
<div class="section" id="s17">
  <h2><span class="icon">üîÑ</span> 17. Instruction Cycle</h2>

  <div class="keybox">The processor executes a program by going through a <strong>cycle for each instruction</strong>. This cycle is called the <strong>Instruction Cycle</strong>.</div>

  <div class="mnemonic">
    <div class="label">üß† Memory Trick ‚Äî 4 Phases</div>
    <p><strong>"FDRE"</strong> ‚Üí <strong>F</strong>etch ‚Üí <strong>D</strong>ecode ‚Üí <strong>R</strong>ead EA ‚Üí <strong>E</strong>xecute</p>
  </div>

  <div class="steps">
    <div class="step"><div class="step-num">1</div><div class="step-text"><strong>Fetch:</strong> Get the instruction from memory (address in PC)</div></div>
    <div class="step"><div class="step-num">2</div><div class="step-text"><strong>Decode:</strong> Determine what instruction it is and how many operands are needed. Opcode moved to appropriate registers.</div></div>
    <div class="step"><div class="step-num">3</div><div class="step-text"><strong>Read EA:</strong> Read the effective address / fetch operand values from memory</div></div>
    <div class="step"><div class="step-num">4</div><div class="step-text"><strong>Execute:</strong> Perform the operation specified by the instruction</div></div>
  </div>

  <h3>Execution of Complete Instruction ‚Äî Example: Add (R3), R1</h3>
  <div class="steps">
    <div class="step"><div class="step-num">1</div><div class="step-text">Fetch the instruction from memory</div></div>
    <div class="step"><div class="step-num">2</div><div class="step-text">Fetch first operand (contents of memory location pointed by R3)</div></div>
    <div class="step"><div class="step-num">3</div><div class="step-text">Perform the addition</div></div>
    <div class="step"><div class="step-num">4</div><div class="step-text">Load result into R1</div></div>
  </div>

  <h3>Branch Instruction Execution</h3>
  <div class="keybox">
    A branch instruction <strong>replaces PC</strong> with the branch target address. Target address = obtained by adding offset X (from instruction) to PC. The offset X = difference between branch target and address following the branch instruction. Offset is a <strong>signed number</strong> (can be + or ‚Äì).
  </div>
</div>

<!-- ===== SECTION 18 ===== -->
<div class="section" id="s18">
  <h2><span class="icon">üèéÔ∏è</span> 18. Single Bus vs Multiple Bus Organization</h2>

  <div class="keybox">In processor organization, buses connect registers, ALU, memory, and I/O. The number of buses affects how many operations can occur simultaneously.</div>

  <div class="compare">
    <div class="compare-box arch">
      <h4>Single Bus Organization</h4>
      <ul>
        <li>One shared bus for all transfers</li>
        <li>Only one operation per clock cycle</li>
        <li>Sequential steps for each instruction</li>
        <li>Simple, lower cost</li>
        <li>Example: Add R4, R5 ‚Üí multiple steps</li>
      </ul>
    </div>
    <div class="compare-box org">
      <h4>Multiple Bus Organization</h4>
      <ul>
        <li>Separate A-bus, B-bus, C-bus</li>
        <li>Two source operands simultaneously</li>
        <li>Fewer clock cycles per instruction</li>
        <li>Example: Add R4, R5, R6 in 4 steps instead of many</li>
        <li>Higher performance, higher cost</li>
      </ul>
    </div>
  </div>

  <h3>3-Bus Organization Example: Add R4, R5, R6</h3>
  <table>
    <tr><th>Step</th><th>Action</th></tr>
    <tr><td>1</td><td>PCout, R=B, MARin, Read, IncPC</td></tr>
    <tr><td>2</td><td>WMFC (wait for memory)</td></tr>
    <tr><td>3</td><td>MDRout, R=B, IRin</td></tr>
    <tr><td>4</td><td>R4outA, R5outB, SelectA, Add, R6in, End</td></tr>
  </table>

  <div class="mnemonic">
    <div class="label">üß† Key Difference</div>
    <p>With 3 buses, you can read TWO source registers (R4 on Bus A, R5 on Bus B) simultaneously in ONE step, and write result to R6. Much faster than single bus!</p>
  </div>
</div>

<!-- FINAL QUICK RECALL -->
<div class="recall">
  <div class="rl">‚ö° Last-Minute Quick Recall</div>
  <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top:8px; font-size:0.85rem; color:#fde68a;">
    <div>‚Ä¢ CA = WHAT | CO = HOW</div>
    <div>‚Ä¢ 5 units: I M A C O</div>
    <div>‚Ä¢ PC ‚Üí next instruction address</div>
    <div>‚Ä¢ IR ‚Üí current instruction</div>
    <div>‚Ä¢ MAR ‚Üí address to access</div>
    <div>‚Ä¢ MDR ‚Üí data read/written</div>
    <div>‚Ä¢ Instruction cycle: FDRE</div>
    <div>‚Ä¢ Load = Read | Store = Write</div>
    <div>‚Ä¢ Big-Endian: MSB first</div>
    <div>‚Ä¢ Little-Endian: LSB first</div>
    <div>‚Ä¢ NZVC flags in status register</div>
    <div>‚Ä¢ 0/1/2/3 address instructions</div>
    <div>‚Ä¢ Immediate: operand in instruction</div>
    <div>‚Ä¢ Direct: instruction has address</div>
    <div>‚Ä¢ Register: operand in register</div>
    <div>‚Ä¢ Indirect: register has address</div>
    <div>‚Ä¢ Indexed: EA = X + (Ri)</div>
    <div>‚Ä¢ Relative: EA = PC + offset</div>
    <div>‚Ä¢ Single bus = cheap, slow</div>
    <div>‚Ä¢ Multiple bus = fast, costly</div>
  </div>
</div>

</div><!-- end container -->

<div style="text-align:center; padding: 20px; color: #475569; font-size:0.8rem;">
  üìö Computer Organization &amp; Architecture ‚Äî Module 1 | Good luck on your exam! üéØ
</div>

</body>
</html>
